<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm</title>
</head>
<body>

    <h1>문제 설명</h1>
    <p>
        1937년 Collatz란 사람에 의해 제기된 이 추측은, 
        주어진 수가 1이 될때까지 다음 작업을 반복하면,
         모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.

        1-1. 입력된 수가 짝수라면 2로 나눕니다. 
        1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.
        2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.

        예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 
        위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 
        단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.
    </p>

    
    <h2>제한 조건</h2>
    <ul>
        <li>입력된 수, num은 1 이상 8000000 미만인 정수입니다.</li>
    </ul>



    <script>
        // 풀이 1)
        function solution(num) {
            var answer = 0;
            
            for(let i = 0; i < 500; i++) {
                if(num === 1) {
                    answer = i;
                    break;
                } else if(num % 2 === 0) {
                    num = num / 2;
                } else if(num % 2 !== 0) {
                    num = num * 3 + 1;
                }
                answer = -1;
            }  

            return answer;
        }
        // num === 1 일때도 멈추지 않고 계속해서 계산을 해서 결국 499번이라는 결과를 가져왔다. 
        // 따라서 break를 줘서 answer값이 구해지면 for문이 그만 돌도록 빠져나오게 해줬다.

        // 어떤 상황에 무한대로 함수가 돌아가서 break가 필요한지 한 번에 판단하질 못하겠다.

        // 위의 함수를 삼항연산자를 이용해 적어보려다 실패..
        // 삼항연산자 이용할 방법을 생각해보자...





        // 다른사람 풀이 1)
        function solution(num) {
            var answer = 0;

            while(num !=1 && answer !=500){
                num%2==0 ? num = num/2 : num = num*3 +1;
                answer++;
            }

            return num == 1 ? answer : -1;
        }
        // while문을 돌려 num이 1이 될 때까지 answer값에 1씩 추가해줬다.
        // while문 속에서 num이 짝수인지 홀수인지 판단해줬다.


        // for문 : 정해진 횟수만큼 반복.(반복 횟수를 알고 있을 때 주로 사용)
        //        주로 배열과 함께 사용한다.

        // while문 : 조건식이 true일 경우 계속 반복.
        //          무한루프나 특정 조건에 만족할 때까지 반복해야하는 경우 사용한다.
        //          주로 파일을 읽고 쓰기에 사용한다.




        // 다른사람 풀이 2)
        function solution(num,count = 0) {
            return num == 1 ? (count >= 500 ? -1 : count) : solution(num % 2 == 0 ? num / 2 : num * 3 + 1,++count);
        }
        // 삼항연산자를 이용해 푼 풀이법이다!!!

        // solution함수에 애초에 count인자를 넣어줬다. 
        // num이 1일 경우 count의 숫자가 500이상인지 판단해서 결과값을 줬다.
        // num이 1이 아닐 경우, solution함수를 다시 사용해서 짝수인지 홀수인지 판단해 count를 1씩 추가해줬다. ===> num이 1이 될 때까지 반복.


        // ***************************** 재귀함수 ****************************
        // 재귀함수 : 한 함수가 자기자신을 호출하는 것.
        
        //-------재귀함수  첫 번째 예시--------------------------------------

        function factorial(x) {
            if (x<0) return;
            if (x===0) return 1;
            return x * factorial(x-1);
        }
        factorial(3);  // 6       
        // !3과 같은 결과가 나온다.('팩토리얼' 개념)
        // 팩토리얼이란 본인을 포함한 본인보다 작은 정수를 모두 곱한 값이다.
        // ex) !4 = 4(3)(2)(1) = 24


        // 재귀함수는 3가지 조건이 필요하다.
        // 1. 종료 조건  /  2. 기반 조건(Base case,기저상태)  /  3. 재귀

        // 1. 종료 조건 : 좋지 않은 입력값이 들어왔을 때 재귀가 계속해서 동작하는 것을 방지해줌.
        //              위의 예시에서 if (x<0) return;을 준것이 종료 조건.
        // 2. 기반 조건 : 성공으로 인한 종료 조건을 주는 것.
        //              위의 예시에서  if (x===0) return 1; 가 기반조건이다. 
        //               ( x가 0일 경우 1을 리턴해준다는 것. )    
        // 3. 재귀 : 함수가 자기 자신을 호출하는 것. 
        //          위의 예시에서  return x * factorial(x-1); 부분이 실제로 재귀가 일어나는 부분. 

        //---------------------------------------------


        //-------재귀함수 두 번째 예시--------------------------------------

        function revStr(str) {
            if (str === '') return '';
            return revStr(str.substr(1)) + str[0];
        }
        revStr('cat')  // tac
        // str === '' 부분이 기반조건이다.
        // return revStr(str.substr(1)) + str[0]; 부분이 재귀가 일어나는 코드라인이다.
        // 종료조건은 없다. 이 예시에서는 기반 조건이 곧 종료 조건이기 때문.
        // 문자열은 음수와 같은 특성을 가질 수 없다. 따라서 첫 번째 예시와 달리 음수일 경우의 종료 조건을 줄 필요가 없는 것이다.

        //---------------------------------------------

        // https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-33%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90-23-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9E%AC%EA%B7%80Recursion-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0  참고
        // ******************************************************************


    </script>
    
</body>
</html>